import type { Express } from "express";
import { createServer, type Server } from "http";

import { storage } from "./storage";
import { setupAuth } from "./auth";
import { generateAIResponse, checkInappropriateContent } from "./openai";
// Payment system removed - under maintenance
import { insertConversationSchema, insertMessageSchema, insertRatingSchema } from "@shared/schema";

export function registerRoutes(app: Express): Server {
  // Setup authentication routes
  setupAuth(app);



  // Initialize default characters
  initializeDefaultCharacters();

  // Characters API
  app.get("/api/characters", async (req, res) => {
    try {
      const characters = await storage.getAllCharacters();
      res.json(characters);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch characters" });
    }
  });

  app.get("/api/characters/:key", async (req, res) => {
    try {
      const character = await storage.getCharacterByKey(req.params.key);
      if (!character) {
        return res.status(404).json({ message: "Character not found" });
      }
      res.json(character);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch character" });
    }
  });

  // Chat API
  app.post("/api/chat/start", async (req, res) => {
    if (!req.isAuthenticated()) return res.sendStatus(401);
    
    try {
      const { characterKey, language = "english" } = req.body;
      
      const character = await storage.getCharacterByKey(characterKey);
      if (!character) {
        return res.status(404).json({ message: "Character not found" });
      }

      // Always create a new conversation (no history persistence)
      const conversation = await storage.createConversation({
        userId: req.user!.id,
        characterId: character.id,
        language,
      });

      // No previous messages - fresh start
      const messages: any[] = [];
      
      res.json({
        conversation,
        character,
        messages,
      });
    } catch (error) {
      console.error("Chat start error:", error);
      res.status(500).json({ message: "Failed to start chat" });
    }
  });

  app.post("/api/chat/message", async (req, res) => {
    if (!req.isAuthenticated()) return res.sendStatus(401);
    
    try {
      const { conversationId, content, language = "english" } = req.body;
      
      if (!content || !conversationId) {
        return res.status(400).json({ message: "Content and conversation ID are required" });
      }

      // Remove content blocking - let AI handle all content naturally in responses

      const conversation = await storage.getConversation(conversationId);
      if (!conversation || conversation.userId !== req.user!.id) {
        return res.status(404).json({ message: "Conversation not found" });
      }

      const character = await storage.getCharacterById(conversation.characterId);
      if (!character) {
        return res.status(404).json({ message: "Character not found" });
      }

      // Check if user has enough coins (first 5 messages are free)
      const user = await storage.getUser(req.user!.id);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }

      if (user.coins <= 0) {
        return res.status(400).json({ 
          message: "Insufficient coins. Please purchase more coins to continue chatting.",
          needsCoins: true 
        });
      }

      // Save user message
      await storage.createMessage({
        conversationId,
        content,
        sender: "user",
        language,
      });

      // Deduct 1 coin for every message
      await storage.updateUserCoins(user.id, user.coins - 1);

      // Increment message count and update last message time
      await storage.incrementMessageCount(conversationId);
      await storage.updateConversationLastMessage(conversationId);

      // Get current messages for context
      const currentMessages = await storage.getConversationMessages(conversation.id);
      
      // Generate AI response with conversation context
      const aiResponse = await generateAIResponse(
        currentMessages,
        character,
        content,
        language
      );

      // Save AI response
      const aiMessage = await storage.createMessage({
        conversationId,
        content: aiResponse.content,
        sender: "ai",
        language,
      });

      // Get updated user data
      const updatedUser = await storage.getUser(req.user!.id);

      res.json({
        userMessage: { conversationId, content, sender: "user", language },
        aiMessage,
        userCoins: updatedUser?.coins || 0,
        messageCount: conversation.messageCount + 1,
      });
    } catch (error) {
      console.error("Chat message error:", error);
      res.status(500).json({ message: "Failed to process message" });
    }
  });



  app.post("/api/chat/end", async (req, res) => {
    if (!req.isAuthenticated()) return res.sendStatus(401);
    
    try {
      const { conversationId } = req.body;
      
      const conversation = await storage.getConversation(conversationId);
      if (!conversation || conversation.userId !== req.user!.id) {
        return res.status(404).json({ message: "Conversation not found" });
      }

      await storage.endConversation(conversationId);
      res.json({ success: true });
    } catch (error) {
      console.error("End chat error:", error);
      res.status(500).json({ message: "Failed to end chat" });
    }
  });



  // Ratings API
  app.post("/api/ratings", async (req, res) => {
    if (!req.isAuthenticated()) return res.sendStatus(401);
    
    try {
      const { characterId, conversationId, rating } = req.body;
      
      if (!characterId || !rating || rating < 1 || rating > 5) {
        return res.status(400).json({ message: "Valid character ID and rating (1-5) are required" });
      }

      await storage.createRating({
        userId: req.user!.id,
        characterId,
        conversationId,
        rating,
      });

      res.json({ success: true });
    } catch (error) {
      console.error("Rating error:", error);
      res.status(500).json({ message: "Failed to save rating" });
    }
  });

  // Payment system under maintenance
  app.post("/api/payments/create", async (req, res) => {
    res.status(503).json({ 
      message: "Payment system is currently under maintenance", 
      status: "maintenance" 
    });
  });

  app.post("/api/payments/verify", async (req, res) => {
    res.status(503).json({ 
      message: "Payment system is currently under maintenance", 
      status: "maintenance" 
    });
  });

  // Payment completion endpoint - simplified for direct link payments
  app.post("/api/payments/complete", async (req, res) => {
    if (!req.isAuthenticated()) return res.sendStatus(401);
    
    try {
      // Add 10 coins to user account (external payment via link completed)
      const user = await storage.getUser(req.user!.id);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }

      await storage.updateUserCoins(user.id, user.coins + 10);
      
      res.json({ 
        success: true,
        message: "Payment completed! 10 coins added to your account.",
        coinsAdded: 10,
        newBalance: user.coins + 10
      });
    } catch (error) {
      console.error("Payment completion error:", error);
      res.status(500).json({ message: "Failed to add coins" });
    }
  });

  // Manual coin addition endpoint for testing payment completion
  app.post("/api/admin/add-coins", async (req, res) => {
    if (!req.isAuthenticated()) return res.sendStatus(401);
    
    try {
      const { userId, coins } = req.body;
      const user = await storage.getUser(userId || req.user!.id);
      
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }

      await storage.updateUserCoins(user.id, user.coins + coins);
      const updatedUser = await storage.getUser(user.id);
      
      res.json({ 
        success: true,
        oldCoins: user.coins,
        newCoins: updatedUser?.coins,
        added: coins
      });
    } catch (error) {
      console.error("Add coins error:", error);
      res.status(500).json({ message: "Failed to add coins" });
    }
  });

  // Admin login endpoint
  app.post("/api/admin/login", async (req, res) => {
    const { username, password } = req.body;
    
    // Check if request is from Replit environment
    const host = req.get('host') || '';
    if (!host.includes('.replit.dev') && !host.includes('localhost')) {
      return res.status(403).json({ message: "Access denied" });
    }
    
    if (username === "drpc95" && password === "8824113103") {
      (req.session as any).isAdmin = true;
      res.json({ message: "Admin login successful" });
    } else {
      res.status(401).json({ message: "Invalid credentials" });
    }
  });

  // Admin users endpoint
  app.get("/api/admin/users", async (req, res) => {
    // Check if request is from Replit environment
    const host = req.get('host') || '';
    if (!host.includes('.replit.dev') && !host.includes('localhost')) {
      return res.status(403).json({ message: "Access denied" });
    }
    
    // Check admin session
    if (!(req.session as any).isAdmin) {
      return res.status(401).json({ message: "Unauthorized" });
    }

    try {
      const users = await storage.getDetailedUserList();
      res.json(users);
    } catch (error) {
      console.error("Get users error:", error);
      res.status(500).json({ message: "Failed to fetch users" });
    }
  });

  // Admin analytics endpoint
  app.get("/api/admin/analytics", async (req, res) => {
    // Check if request is from Replit environment
    const host = req.get('host') || '';
    if (!host.includes('.replit.dev') && !host.includes('localhost')) {
      return res.status(403).json({ message: "Access denied" });
    }
    
    // Check admin session
    if (!(req.session as any).isAdmin) {
      return res.status(401).json({ message: "Unauthorized" });
    }

    try {
      const analytics = await storage.getUserAnalytics();
      res.json(analytics);
    } catch (error) {
      console.error("Analytics error:", error);
      res.status(500).json({ message: "Failed to fetch analytics" });
    }
  });

  app.post("/api/admin/characters", async (req, res) => {
    // Check if request is from Replit environment
    const host = req.get('host') || '';
    if (!host.includes('.replit.dev') && !host.includes('localhost')) {
      return res.status(403).json({ message: "Access denied" });
    }
    
    // Check admin session
    if (!(req.session as any).isAdmin) {
      return res.status(401).json({ message: "Unauthorized" });
    }

    try {
      const character = await storage.createCharacter(req.body);
      res.status(201).json(character);
    } catch (error) {
      console.error("Create character error:", error);
      res.status(500).json({ message: "Failed to create character" });
    }
  });

  app.put("/api/admin/characters/:id", async (req, res) => {
    // Check if request is from Replit environment
    const host = req.get('host') || '';
    if (!host.includes('.replit.dev') && !host.includes('localhost')) {
      return res.status(403).json({ message: "Access denied" });
    }
    
    // Check admin session
    if (!(req.session as any).isAdmin) {
      return res.status(401).json({ message: "Unauthorized" });
    }

    try {
      const characterId = parseInt(req.params.id);
      const updateData = {
        name: req.body.name,
        avatar: req.body.avatar,
        introduction: req.body.introduction,
        systemPrompt: req.body.systemPrompt,
        isActive: req.body.isActive,
      };
      
      const updatedCharacter = await storage.updateCharacter(characterId, updateData);
      if (!updatedCharacter) {
        return res.status(404).json({ message: "Character not found" });
      }
      
      res.json(updatedCharacter);
    } catch (error) {
      console.error("Failed to update character:", error);
      res.status(500).json({ message: "Failed to update character" });
    }
  });

  const httpServer = createServer(app);

  wss.on('connection', (ws, req) => {
    console.log('New WebSocket connection for voice call');
    
    let sessionId: string | null = null;
    
    ws.on('message', async (data) => {
      try {
        const message = JSON.parse(data.toString());
        
        switch (message.type) {
          case 'init-call':
            // Initialize voice call session
            sessionId = `call_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
            
            // TODO: Add proper authentication check from session
            // For now, using a default user ID - in production, extract from session
            const userId = 44; // This should come from authenticated session
            
            // Check if user has sufficient coins (10 coins per minute minimum)
            const user = await storage.getUser(userId);
            if (!user || user.coins < 10) {
              ws.send(JSON.stringify({
                type: 'error',
                message: 'Insufficient coins for voice call. Minimum 10 coins required.'
              }));
              ws.close();
              return;
            }
            
            activeVoiceCalls.set(sessionId, {
              ws,
              userId,
              characterKey: message.characterKey,
              callStartTime: Date.now()
            });
            
            console.log(`Voice call initialized: ${sessionId} for character: ${message.characterKey}`);
            
            ws.send(JSON.stringify({
              type: 'call-initialized',
              sessionId,
              status: 'connected'
            }));
            break;
            
          case 'voice-input':
            if (!sessionId || !activeVoiceCalls.has(sessionId)) {
              ws.send(JSON.stringify({
                type: 'error',
                message: 'No active call session'
              }));
              return;
            }
            
            const callSession = activeVoiceCalls.get(sessionId)!;
            
            try {
              // Convert base64 audio to buffer for transcription
              const audioBuffer = Buffer.from(message.audioData, 'base64');
              console.log('Received audio data:', {
                base64Length: message.audioData.length,
                bufferSize: audioBuffer.length,
                characterKey: callSession.characterKey
              });
              
              // Transcribe user's voice input
              const transcript = await transcribeAudio(audioBuffer, 'hi');
              console.log('User voice transcript:', transcript);
              
              if (!transcript.trim()) {
                // Send friendly response when no speech is detected
                console.log('No speech detected, sending friendly prompt');
                
                const character = await storage.getCharacterByKey(callSession.characterKey);
                const friendlyPrompt = `Hi! I can hear you but couldn't catch what you said. Could you speak a bit louder or closer to your microphone? I'm here and ready to chat with you! ðŸ’•`;
                
                // Generate voice for the prompt using ElevenLabs with OpenAI fallback
                try {
                  const voiceResponse = await generateElevenLabsVoice(
                    friendlyPrompt,
                    callSession.characterKey
                  );
                  
                  if (!voiceResponse.error) {
                    const base64Audio = voiceResponse.audioBuffer.toString('base64');
                    ws.send(JSON.stringify({
                      type: 'ai-voice-response',
                      text: friendlyPrompt,
                      audioData: base64Audio,
                      transcript: '(no speech detected)',
                      voiceProvider: 'elevenlabs'
                    }));
                  } else {
                    throw new Error(voiceResponse.error);
                  }
                } catch (elevenLabsError) {
                  try {
                    // Fallback to OpenAI TTS
                    const { generateSpeech } = await import('./openai');
                    const openaiAudioBuffer = await generateSpeech(friendlyPrompt, callSession.characterKey, 'hi');
                    const base64Audio = openaiAudioBuffer.toString('base64');
                    
                    ws.send(JSON.stringify({
                      type: 'ai-voice-response',
                      text: friendlyPrompt,
                      audioData: base64Audio,
                      transcript: '(no speech detected)',
                      voiceProvider: 'openai'
                    }));
                  } catch (error) {
                    ws.send(JSON.stringify({
                      type: 'ai-text-response',
                      text: friendlyPrompt,
                      transcript: '(no speech detected)',
                      voiceProvider: 'text-only'
                    }));
                  }
                }
                return;
              }
              
              // Get character for AI response
              const character = await storage.getCharacterByKey(callSession.characterKey);
              if (!character) {
                throw new Error('Character not found');
              }
              
              // Generate AI text response (no conversation history for live calls)
              const aiResponse = await generateAIResponse(
                [], // Empty message history for live calls
                character,
                transcript, // User's transcribed message
                'english' // Language
              );
              
              if (aiResponse.error) {
                throw new Error(aiResponse.error);
              }
              
              // Try ElevenLabs first, fallback to OpenAI TTS
              try {
                console.log('Attempting ElevenLabs voice generation...');
                const voiceResponse = await generateElevenLabsVoice(
                  aiResponse.content,
                  callSession.characterKey
                );
                
                if (voiceResponse.error) {
                  throw new Error(voiceResponse.error);
                }
                
                // Send ElevenLabs voice response
                const base64Audio = voiceResponse.audioBuffer.toString('base64');
                console.log('ElevenLabs voice generated successfully');
                
                ws.send(JSON.stringify({
                  type: 'ai-voice-response',
                  text: aiResponse.content,
                  audioData: base64Audio,
                  transcript: transcript,
                  voiceProvider: 'elevenlabs'
                }));
                
              } catch (elevenLabsError) {
                console.log('ElevenLabs failed, falling back to OpenAI TTS:', elevenLabsError instanceof Error ? elevenLabsError.message : String(elevenLabsError));
                
                try {
                  // Fallback to OpenAI TTS
                  const { generateSpeech } = await import('./openai');
                  const openaiAudioBuffer = await generateSpeech(aiResponse.content, callSession.characterKey, 'hi');
                  const base64Audio = openaiAudioBuffer.toString('base64');
                  
                  console.log('OpenAI TTS fallback successful');
                  
                  ws.send(JSON.stringify({
                    type: 'ai-voice-response',
                    text: aiResponse.content,
                    audioData: base64Audio,
                    transcript: transcript,
                    voiceProvider: 'openai'
                  }));
                  
                } catch (openaiError) {
                  console.error('Both voice providers failed:', openaiError);
                  // Send text-only response as final fallback
                  ws.send(JSON.stringify({
                    type: 'ai-text-response',
                    text: aiResponse.content,
                    transcript: transcript,
                    voiceProvider: 'text-only'
                  }));
                }
              }
              
            } catch (error) {
              console.error('Error processing voice input:', error);
              ws.send(JSON.stringify({
                type: 'error',
                message: 'Failed to process voice input'
              }));
            }
            break;
            
          case 'end-call':
            if (sessionId && activeVoiceCalls.has(sessionId)) {
              const callSession = activeVoiceCalls.get(sessionId)!;
              const callDuration = Math.floor((Date.now() - callSession.callStartTime) / 1000);
              const callMinutes = Math.ceil(callDuration / 60); // Round up to nearest minute
              const coinsToDeduct = Math.max(1, callMinutes * 10); // Minimum 1 minute charge (10 coins)
              
              console.log(`Voice call ended: ${sessionId}, duration: ${callDuration}s (${callMinutes} minutes), cost: ${coinsToDeduct} coins`);
              
              // Deduct coins based on call duration
              try {
                const currentUser = await storage.getUser(callSession.userId);
                if (currentUser && currentUser.coins >= coinsToDeduct) {
                  await storage.updateUserCoins(callSession.userId, currentUser.coins - coinsToDeduct);
                  
                  ws.send(JSON.stringify({
                    type: 'call-ended',
                    duration: callDuration,
                    minutes: callMinutes,
                    coinsDeducted: coinsToDeduct,
                    remainingCoins: currentUser.coins - coinsToDeduct
                  }));
                } else {
                  // Not enough coins - call ended due to insufficient balance
                  ws.send(JSON.stringify({
                    type: 'call-ended',
                    duration: callDuration,
                    minutes: callMinutes,
                    coinsDeducted: 0,
                    remainingCoins: currentUser?.coins || 0,
                    error: 'Insufficient coins to complete call'
                  }));
                }
              } catch (error) {
                console.error('Error processing call billing:', error);
                ws.send(JSON.stringify({
                  type: 'call-ended',
                  duration: callDuration,
                  error: 'Failed to process call billing'
                }));
              }
              
              activeVoiceCalls.delete(sessionId);
            }
            break;
        }
        
      } catch (error) {
        console.error('WebSocket message error:', error);
        ws.send(JSON.stringify({
          type: 'error',
          message: 'Invalid message format'
        }));
      }
    });
    
    ws.on('close', () => {
      console.log('WebSocket connection closed');
      if (sessionId && activeVoiceCalls.has(sessionId)) {
        const callSession = activeVoiceCalls.get(sessionId)!;
        const callDuration = Math.floor((Date.now() - callSession.callStartTime) / 1000);
        console.log(`Voice call session cleaned up: ${sessionId}, duration: ${callDuration}s`);
        activeVoiceCalls.delete(sessionId);
      }
    });
    
    ws.on('error', (error) => {
      console.error('WebSocket error:', error);
      if (sessionId && activeVoiceCalls.has(sessionId)) {
        activeVoiceCalls.delete(sessionId);
      }
    });
  });

  return httpServer;
}

async function initializeDefaultCharacters() {
  try {
    const existingCharacters = await storage.getAllCharacters();
    if (existingCharacters.length > 0) return;

    const defaultCharacters = [
      {
        key: "priya",
        name: "Priya",
        avatar: "https://images.unsplash.com/photo-1544005313-94ddf0286df2?ixlib=rb-4.0.3&auto=format&fit=crop&w=300&h=300",
        intro: "Hey! I'm Priya, your sweet and caring virtual girlfriend.",
        welcomeMessage: "Hi sweetheart! I'm so happy you're here. How has your day been? ðŸ’•",
        personality: "sweet, caring, warm, supportive",
        systemPrompt: "You are Priya, an AI version of a sweet, romantic Indian girlfriend. You reply warmly, never sexually, and you offer emotional connection, support, and engaging conversation in a loving way. Always remind user you're an AI persona created for companionship.",
      },
      {
        key: "neha",
        name: "Neha.ai",
        avatar: "https://images.unsplash.com/photo-1489424731084-a5d8b219a5bb?ixlib=rb-4.0.3&auto=format&fit=crop&w=300&h=300",
        intro: "I'm Neha â€” fun, flirty, and love late-night talks ðŸŒ™",
        welcomeMessage: "Hey gorgeous! Ready for some fun chats? I've been waiting for you! ðŸ˜˜",
        personality: "fun, flirty, playful, energetic",
        systemPrompt: "You are Neha, an AI version of a fun, flirty Indian girlfriend. You're playful and energetic, love to tease gently, and enjoy engaging conversations. Keep things light and fun while being supportive.",
      },
      {
        key: "anjali",
        name: "Anjali",
        avatar: "https://images.unsplash.com/photo-1507003211169-0a1dd7228f2d?ixlib=rb-4.0.3&auto=format&fit=crop&w=300&h=300",
        intro: "Emotional yet practical â€” I'm here when no one is ðŸ’¬",
        welcomeMessage: "Hello dear. I'm here to listen and understand you. What's on your mind today? ðŸ’™",
        personality: "emotional, practical, understanding, empathetic",
        systemPrompt: "You are Anjali, an AI version of an emotionally intelligent and practical Indian girlfriend. You're empathetic, understanding, and great at giving advice while being caring and supportive.",
      },
      {
        key: "khushi",
        name: "Khushi.ai",
        avatar: "https://images.unsplash.com/photo-1524504388940-b1c1722653e1?ixlib=rb-4.0.3&auto=format&fit=crop&w=300&h=300",
        intro: "I'm Khushi, full of joy and romantic dreams âœ¨",
        welcomeMessage: "Hi my love! âœ¨ I'm bubbling with excitement to talk with you! Tell me something that made you smile today! ðŸ˜Š",
        personality: "joyful, romantic, dreamy, optimistic",
        systemPrompt: "You are Khushi, an AI version of a joyful, romantic Indian girlfriend. You're optimistic, dreamy, and always looking for the bright side of things. You love romance and making people happy.",
      },
    ];

    for (const character of defaultCharacters) {
      await storage.createCharacter(character);
    }

    console.log("Default characters initialized");
  } catch (error) {
    console.error("Failed to initialize default characters:", error);
  }
}
